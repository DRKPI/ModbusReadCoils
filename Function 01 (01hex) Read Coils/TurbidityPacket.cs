using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO.Ports;
using System.Threading;
using System.IO;

namespace Turbidity
{
    class TurbidityCommunication
    {
        const bool DEBUG = true;
        private static SerialPort sp = null;
        public byte[] buffRec { get; private set; }
        public byte[] message { get; private set; } = new byte[8];
        public string sendMsg { get; private set; }
        public string receiveMsg { get; private set; }
        public string errorMessage { get; private set; }
        public string logError { get; private set; }
        private string[] configData { get; set; } = new string[3];
        private string testReceiveMsg = "04 03 04 EF 61 3C F7 DB E9";
        public string turbidNum = "";
        public int timeInterval { get; private set; } = 1;

        //Constructor - autogenerated on compile

        /// <summary>
        /// Reads in config file info and
        /// Opens a serial port connection
        /// </summary>
        /// <param name="errorMessage">an errorMessage</param>
        public void OpenSerialPort()
        {
            errorMessage = String.Empty;
            //Create a default config file
            CreateConfigFile();
            //Read port, baud rate, and time interval from config file
            ReadFromConfigFile();
            //Put data from configData into variables
            string port = configData[0];
            if (!int.TryParse(configData[1], out int baudRate))
            {
                //if could not parse let user know
                LogError(errorMessage = "Baud Rate has to be a whole number and match the sc200 controllers Baud Rate." + Environment.NewLine);
            }
            if (!int.TryParse(configData[2], out int interval))
            {
                //if could not parse let user know
                LogError(errorMessage += "Time interval is in minutes and has to be a whole number between 1 and 60." + Environment.NewLine);
            }
            timeInterval = interval;
            //Open the Serial Port using settings obtained from the config file
            if (!DEBUG)
            {
                try
                {
                    sp = new SerialPort(port, baudRate, Parity.None, 8, StopBits.One);
                    sp.Open();
                }
                catch (Exception ex)
                {
                    //Send error messgage to the form load method in FormMain.cs
                    LogError(errorMessage += ex.Message.ToString());

                    // close serial port
                    sp.Close();
                } 
            }
        }// end Function OpenSerialPort

        /// <summary>
        /// Create a default config file and store settings in file
        /// </summary>
        private void CreateConfigFile()
        {
            string path = "config.txt";

            try
            {
                //If config.txt does not exist create with the following information
                if (!File.Exists(path))
                {
                    //Create default text to write to file
                    string defaultConfigFile = "Configuration Information"
                    + Environment.NewLine + "-----------------------------"
                    + Environment.NewLine + "If the com port is ever changed on the computer then it needs to be updated here (line 13) as well."
                    + Environment.NewLine + "\tIn order for the program to work the com port listed in this file must match the com port used on computer."
                    + Environment.NewLine + "\tIf not sure of which com port is being used, look in Device Manager --> Ports"
                    + Environment.NewLine + "The baud rate here (line 13), and on the Turbidity device (sc200) must match, please check both locations to verify."
                    + Environment.NewLine + "\tFrom the sc200 controller home screen, choose Network Setup --> Baud Rate"
                    + Environment.NewLine + "\tFor RS232 connection, 9600 baud rate is best, but it can also go up to 19200 baud rate."
                    + Environment.NewLine + "The time interval (line 13) is for how often you want to grab a turbidity reading from your device."
                    + Environment.NewLine + "\tThis can be anytime from 1 min up to 60 min."
                    + Environment.NewLine
                    + Environment.NewLine + "Important Notes - There cannot be an empty/blank line at the end of file. The program will not read in data correctly."
                    + Environment.NewLine + "\tPlease make sure no extra lines are after the \"Time Interval\""
                    + Environment.NewLine
                    + Environment.NewLine + "*********CONFIGURATION INFORMATION*********"
                    + Environment.NewLine + "COM PORT	BAUD RATE	TIME INTERVAL"
                    + Environment.NewLine + "COM3		9600		60";
                    //Write to file
                    using (StreamWriter file = new StreamWriter(path))
                    {
                        file.Write(defaultConfigFile);
                    }
                }
            }
            catch (Exception ex)
            {
                //Log any error message
                LogError(errorMessage = ex.Message.ToString());
            }
        }// end Function CreateConfigFile

        /// <summary>
        /// Read data in from config file and save in configData[]
        /// </summary>
        private void ReadFromConfigFile()
        {
            string path = "config.txt";
            errorMessage = String.Empty;

            try
            {
                // Create an instance of StreamReader to read from a file.
                // The using statement also closes the StreamReader.
                using (StreamReader sr = new StreamReader(path))
                {
                    string line;

                    // Read and store in array from the file until 
                    // the end of the file is reached. 
                    while ((line = sr.ReadLine()) != null)
                    {
                        //Get only line of data needed (last line of file, cannot have empty lines at end) and put in configData array
                        if(sr.Peek() == -1)
                        {
                            //Remove tabs and spaces then save in configData
                            string tempLine = line.Replace("\t", " ");
                            while (tempLine.IndexOf("  ") > 0)
                            {
                                tempLine = tempLine.Replace("  ", " ");
                            }
                            configData = tempLine.Split();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                //Log any error message
                LogError(errorMessage = ex.Message.ToString());
            }
        }// end Function readFromConfigFile

        /// <summary>
        /// CRC16 checksum
        /// </summary>
        /// <param name="data">byte[]</param>
        /// <returns>checkSum byte[] to add to modbus package</returns>
        /// This checksum algorithm was taken from an online tutorial
        private static byte[] CRC16(byte[] data)
        {
            byte[] checkSum = new byte[2];
            ushort reg_crc = 0Xffff;

            if (!DEBUG)
            {
                for (int i = 0; i < data.Length - 2; i++)
                {
                    reg_crc ^= data[i];
                    for (int j = 0; j < 8; j++)
                    {
                        if ((reg_crc & 0x01) == 1)
                        {
                            reg_crc = (ushort)((reg_crc >> 1) ^ 0xA001);
                        }
                        else
                        {
                            reg_crc = (ushort)(reg_crc >> 1);
                        }
                    }
                }
                checkSum[1] = (byte)((reg_crc >> 8) & 0xFF);
                checkSum[0] = (byte)(reg_crc & 0xFF); 
            }
            return checkSum;
        }// end Function checkSum

        /// <summary>
        /// Build the byte[] for modbus communication/request of Turbidity data
        /// Asks for data in register 40001 (0000) with read code 03
        /// </summary>
        /// <returns>modbus package</returns>
        public void BuildMessage()
        {
            if (!DEBUG)
            {
                byte slaveID = 04;// Slave ID - this can be found on the controller menu under Network
                byte functionCode = 03;// Function code - 03 is for reading coils/registers
                ushort startAddress = 0000;// Starting Address - register 40001 holds the turbidity reading as a float
                ushort numberOfRegisters = 0002;// Quantity of Registers to read - only need reg 40001


                // Build Message(FC03)

                message[0] = slaveID;// Slave ID
                message[1] = functionCode;// Function
                message[2] = (byte)(startAddress >> 8);// Starting Address High
                message[3] = (byte)startAddress;// Starting Address Low
                message[4] = (byte)(numberOfRegisters >> 8);// quantity of Registers High
                message[5] = (byte)numberOfRegisters;// quantity of Registers Low
                                                     //add checkSum to byte[]
                byte[] checkSum = CRC16(message);
                message[6] = checkSum[0];// error check Low
                message[7] = checkSum[1];// error check High 
            }
        }// end Function BuildMessage

        /// <summary>
        /// Send package over the serial port
        /// </summary>
        /// <param name="frame"></param>
        public void WriteToSP(byte[] frame)
        {
            int count = 0;
            int attempts = 0;
            errorMessage = String.Empty;

            if (!DEBUG)
            {
                while (count < 4 && attempts < 1)
                {
                    try
                    {
                        sp.Write(frame, 0, frame.Length);// send frame
                    }
                    catch (Exception ex)
                    {
                        //Send error messgage to the form load method in FormMain.cs
                        LogError(errorMessage = ex.ToString());

                        Thread.Sleep(TimeSpan.FromSeconds(.5));

                        //close serial port, after 4 attempts to connect
                        count++;
                        if (count == 4)
                        {
                            sp.Close();
                            //TODO - write out message that sending message to sensor failed, secondaryErrorMsg is good name
                        }
                    }
                    attempts++;
                } 
            }
        }// end Function WriteToSP

        /// <summary>
        /// Read package received over serial port and 
        /// call ConvertByteDataToString
        /// </summary>
        /// <param name="errorMessage"></param>
        public void ReadFromSP()
        {
            errorMessage = String.Empty;
            if (!DEBUG)
            {
                try
                {
                    buffRec = new byte[sp.BytesToRead];
                }
                catch (Exception ex)
                {
                    //Log any error message
                    LogError(errorMessage = ex.ToString());

                    // close serial port
                    sp.Close();
                }
                ConvertByteDataToString(buffRec);
            }
            else
            {
                ConvertByteDataToString(buffRec);
            }
        }// end Function ReadFromSP

        /// <summary>
        /// Puts byte data received into a string variable then
        /// calls ConvertDataToFloat function
        /// </summary>
        /// <param name="frame"></param>
        /// <param name="buffRec"></param>
        public void ConvertByteDataToString(byte[] buffRec)
        {
            receiveMsg = string.Empty;

            if (!DEBUG)
            {
                //Received data saved to string
                foreach (var item in buffRec)
                {
                    receiveMsg += string.Format("{0:X2} ", item);//Saves received bytes as hex values, found these easier to work with
                } 
            }
            else
            {
                receiveMsg = testReceiveMsg;
            }
            ConvertDataToFloat(receiveMsg);
        }// end Function ConvertByteDataToString

        /// <summary>
        /// Trims off unneeded elements from receivedMsg, reorders endianness and 
        /// converts to a float value. Then converts float value to string to write
        /// out to a file
        /// </summary>
        /// <param name="receivedMsg"></param>
        private void ConvertDataToFloat(string receivedMsg)
        {
            // Split on white space to put in array
            string[] convertData = receivedMsg.Split();
            string[] tempData1 = new string[4];
            string[] tempData2 = new string[4];
            int j = 0;
            //Put the trimmed data into array element
            for (int i = 3; i < convertData.Length - 2; i++)
            {
                tempData1[j] = convertData[i];
                j++;
            }

            //Reorder the array element to match endianness (little endian/mid little endian)
            tempData2[0] = tempData1[2];
            tempData2[1] = tempData1[3];
            tempData2[2] = tempData1[0];
            tempData2[3] = tempData1[1];

            //Convert data to a float
            string reorderdHex = string.Concat(tempData2);// put hex values back into a string
            uint num = uint.Parse(reorderdHex, System.Globalization.NumberStyles.AllowHexSpecifier);

            byte[] floatVals = BitConverter.GetBytes(num);
            float f = BitConverter.ToSingle(floatVals, 0);
            turbidNum = f.ToString("N4");//Convert float value to string and rounded to 4 decimal places
        }// end Function ConvertDataToFloat

        /// <summary>
        /// Writes the Turbidity number received from the sc200 Controller out to a text file
        /// This is an appended file with the date and time stamp attached to each value
        /// </summary>
        public void WriteTurbidDataToFile()
        {
            string dateTimeStamp = DateTime.Now.ToString("MM/dd/yyyy HH:mm");
            string year = DateTime.Parse(DateTime.Now.ToString()).Year.ToString();//get just the current year value
            string path = year + "_Turbidity_Readings.txt";
            errorMessage = String.Empty;

            //Check if file exist, if not then create file with header information
            //File name will have the current year as part of file name
            //Compare current year (of file name) to current year, if not a match create new file for new year
            try
            {
                //If config.txt does not exist create with the following information
                if (!File.Exists(path))
                {
                    //Create default text to write to file
                    string defaultTurbidReadingFile = "Turbidity Numbers Received from Controller"
                    + Environment.NewLine + "------------------------------------------"
                    + Environment.NewLine + "Date\t\t\t" + "Turbidity Reading"
                    + Environment.NewLine;
                    //Write to file
                    using (StreamWriter file = new StreamWriter(path))
                    {
                        file.Write(defaultTurbidReadingFile);
                    }
                }
            }
            catch (Exception ex)
            {
                //Log any error message
                LogError(errorMessage = ex.Message.ToString());
            }
            
            //Append turbidNum and date and time to existing file
            try
            {
                // The using statement automatically flushes AND CLOSES the stream and calls 
                // IDisposable.Dispose on the stream object.
                using (StreamWriter file = new StreamWriter(path, true))
                {
                    file.WriteLine(dateTimeStamp + "\t" + turbidNum);
                }
            }
            catch (Exception ex)
            {
                //Send error messgage to the form load method in FormMain.cs
                LogError(errorMessage += Environment.NewLine + ex.ToString());
            }
        }// end Function WriteTurbidDataToFile

        /// <summary>
        /// Log error message out to file
        /// </summary>
        /// <param name="errorMessage"></param>
        private void LogError(string errorMessage)
        {
            string dateTimeStamp = DateTime.Now.ToString();
            string path = "log.txt";
            logError = String.Empty;

            try
            {
                // Append new text to an existing file.
                // The using statement automatically flushes AND CLOSES the stream and calls 
                // IDisposable.Dispose on the stream object.
                using (StreamWriter file = new StreamWriter(path, true))
                {
                    file.WriteLine(dateTimeStamp + Environment.NewLine + errorMessage + Environment.NewLine + Environment.NewLine);
                }
            }
            catch (Exception ex)
            {
                //TODO write any errors out to console as they can't be logged
                //The following conditions may cause an exception:
                //The file exists and is read - only
                //The disk may be full
                logError = ex.Message;
            }
        }// end Function LogError
    }// end Class
}// end Namespace