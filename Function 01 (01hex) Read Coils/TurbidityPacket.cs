using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO.Ports;
using System.Threading;
using System.IO;

namespace Turbidity
{
    class TurbidityPacket
    {
        const bool DEBUG = true;
        private static SerialPort sp = null;
        public byte[] buffRec { get; private set; }
        public byte[] message { get; private set; } = new byte[8];
        public string sendMsg { get; private set; }
        public string receiveMsg { get; private set; }
        public string errorMessage { get; private set; }
        public string logError { get; private set; }
        private string[] configData { get; set; } = new string[3];
        private string testReceiveMsg = "04 03 04 EF 61 3C F7 DB E9";
        public string turbidNum = "";

        //Constructor - autogenerated on compile

        /// <summary>
        /// Opens a serial port
        /// </summary>
        /// <param name="errorMessage">an errorMessage</param>
        public void OpenSerialPort()
        {
            errorMessage = String.Empty;
            //Read port, baud rate, and time interval from config file
            readFromConfigFile();
            //Put data from configData into variables
            string port = configData[0];
            if (!int.TryParse(configData[1], out int baudRate))
            {
                //TODO if could not parse let user know
            }

            if (!DEBUG)
            {
                try
                {
                    sp = new SerialPort(port, baudRate, Parity.None, 8, StopBits.One);
                    sp.Open();
                }
                catch (Exception ex)
                {
                    //Send error messgage to the form load method in FormMain.cs
                    LogError(errorMessage = ex.Message.ToString());

                    // close serial port
                    sp.Close();
                } 
            }
            else
            {

            }
        }

        /// <summary>
        /// CRC16 checksum
        /// </summary>
        /// <param name="data">byte[]</param>
        /// <returns>checkSum byte[] to add to modbus package</returns>
        /// This checksum algorithm was taken from an online tutorial
        private static byte[] CRC16(byte[] data)
        {
            
            byte[] checkSum = new byte[2];
            ushort reg_crc = 0Xffff;

            if (!DEBUG)
            {
                for (int i = 0; i < data.Length - 2; i++)
                {
                    reg_crc ^= data[i];
                    for (int j = 0; j < 8; j++)
                    {
                        if ((reg_crc & 0x01) == 1)
                        {
                            reg_crc = (ushort)((reg_crc >> 1) ^ 0xA001);
                        }
                        else
                        {
                            reg_crc = (ushort)(reg_crc >> 1);
                        }
                    }
                }
                checkSum[1] = (byte)((reg_crc >> 8) & 0xFF);
                checkSum[0] = (byte)(reg_crc & 0xFF); 
            }
            else
            {

            }
            return checkSum;
        }// end Function checkSum

        /// <summary>
        /// Build the byte[] for modbus communication
        /// </summary>
        /// <returns>modbus package</returns>
        public void BuildMessage()
        {
            if (!DEBUG)
            {
                byte slaveID = 04;// Slave ID - this can be found on the controller menu under Network
                byte functionCode = 03;// Function code - 03 is for reading coils/registers
                ushort startAddress = 0000;// Starting Address - register 40001 holds the turbidity reading as a float
                ushort numberOfRegisters = 0002;// Quantity of Registers to read - only need reg 40001


                // Build Message(FC03)

                message[0] = slaveID;// Slave ID
                message[1] = functionCode;// Function
                message[2] = (byte)(startAddress >> 8);// Starting Address High
                message[3] = (byte)startAddress;// Starting Address Low
                message[4] = (byte)(numberOfRegisters >> 8);// quantity of Registers High
                message[5] = (byte)numberOfRegisters;// quantity of Registers Low
                                                     //add checkSum to byte[]
                byte[] checkSum = CRC16(message);
                message[6] = checkSum[0];// error check Low
                message[7] = checkSum[1];// error check High 
            }
            else
            {

            }
        }// end Function BuildMessage

        /// <summary>
        /// Send package over the serial port
        /// </summary>
        /// <param name="frame"></param>
        public void WriteToSP(byte[] frame)
        {
            int count = 0;
            int attempts = 0;
            errorMessage = String.Empty;

            if (!DEBUG)
            {
                while (count < 4 && attempts < 1)
                {
                    try
                    {
                        sp.Write(frame, 0, frame.Length);// send frame
                    }
                    catch (Exception ex)
                    {
                        //Send error messgage to the form load method in FormMain.cs
                        LogError(errorMessage = ex.ToString());

                        Thread.Sleep(TimeSpan.FromSeconds(.5));

                        //close serial port, after 4 attempts to connect
                        count++;
                        if (count == 4)
                        {
                            sp.Close();
                            //TODO add message that write failed
                        }
                    }
                    attempts++;
                } 
            }
            else
            {

            }
        }// end Function WriteToSP

        /// <summary>
        /// Read package received over serial port
        /// </summary>
        /// <param name="errorMessage"></param>
        public void ReadFromSP()
        {
            errorMessage = String.Empty;
            if (!DEBUG)
            {
                try
                {
                    buffRec = new byte[sp.BytesToRead];
                }
                catch (Exception ex)
                {
                    //Log any error message
                    LogError(errorMessage = ex.ToString());

                    // close serial port
                    sp.Close();
                } 
            }
            else
            {
                //When converting data from actual meter testReceiveMsg needs to be replaced with receiveMsg
                string[] testData = testReceiveMsg.Split();// Split on white space to put in array
                string[] tempData1 = new string[4];
                string[] tempData2 = new string[4];
                int j = 0;
                //Put the trimmed data into array element
                for (int i = 3; i < testData.Length - 2; i++)
                {
                    tempData1[j] = testData[i];
                    j++;
                }

                //Reorder the array element to match endianness (little endian/mid little endian)
                tempData2[0] = tempData1[2];
                tempData2[1] = tempData1[3];
                tempData2[2] = tempData1[0];
                tempData2[3] = tempData1[1];

                //Convert data to a float
                string reorderdHex = string.Concat(tempData2);// put hex values back into a string
                uint num = uint.Parse(reorderdHex, System.Globalization.NumberStyles.AllowHexSpecifier);

                byte[] floatVals = BitConverter.GetBytes(num);
                float f = BitConverter.ToSingle(floatVals, 0);
                turbidNum = f.ToString("N4");//Convert float value to string and rounded to 4 decimal places
            }
        }// end Function ReadFromSP

        /// <summary>
        /// Prints data out to WinForm and .CSV file
        /// </summary>
        /// <param name="frame"></param>
        /// <param name="buffRec"></param>
        public void PrintModbusMessage(byte[] frame, byte[] buffRec)
        {
            //sendMsg = string.Empty;
            receiveMsg = string.Empty;

            //Send string
            //This is useful for trouble shooting issues with request to the Turbidity Meter
            foreach (var item in frame)
            {
                sendMsg += string.Format("{0:X2} ", item);
            }

            //Receive string
            foreach (var item in buffRec)
            {
                receiveMsg += string.Format("{0:X2} ", item);
                //TODO - Get only bytes that have turbidity reading
                //TODO - To convert to float flip for endianess then convert
                //TODO - write out number along with date and time to file
            }
        
        }// end Function PrintModbusMessage

        /// <summary>
        /// Log error message out to file
        /// </summary>
        /// <param name="errorMessage"></param>
        private void LogError(string errorMessage)
        {
            string dateTimeStamp = DateTime.Now.ToString();
            string path = "log.txt";
            logError = String.Empty;
            try
            {
                // Append new text to an existing file.
                // The using statement automatically flushes AND CLOSES the stream and calls 
                // IDisposable.Dispose on the stream object.
                using (StreamWriter file =
                    new StreamWriter(path, true))
                {
                    file.WriteLine(dateTimeStamp + Environment.NewLine + errorMessage + Environment.NewLine + Environment.NewLine);
                }
            }
            catch (Exception ex)
            {
                //TODO write any errors out to console as they can't be logged
                //The following conditions may cause an exception:
                //The file exists and is read - only
                //The disk may be full
                logError = ex.Message;
            }
        }// end Function LogError

        /// <summary>
        /// Read data in from config file and save in configData[]
        /// </summary>
        private void readFromConfigFile()
        {
            string path = "log.txt";
            errorMessage = String.Empty;
            try
            {
                // Create an instance of StreamReader to read from a file.
                // The using statement also closes the StreamReader.
                using (StreamReader sr = new StreamReader(path))
                {
                    string line;

                    // Read and store in array from the file until 
                    // the end of the file is reached. 
                    while ((line = sr.ReadLine()) != null)
                    {
                        //TODO call method to get only line of data needed and put in configData array

                    }
                }
            }
            catch (Exception ex)
            {
                //Log any error message
                LogError(errorMessage = ex.Message.ToString());
            }
        }// end Function readFromConfigFile
    }
}



//TODO create new data file for each year - in file name include date/year and check that value with current year, if different create new file