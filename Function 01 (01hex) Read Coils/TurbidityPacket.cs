using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO.Ports;
using System.Threading;
using System.IO;

namespace Turbidity
{
    class TurbidityPacket
    {
        private static SerialPort sp = null;
        public byte[] buffRec { get; private set; }
        public byte[] message { get; private set; } = new byte[8];
        public string sendMsg { get; private set; }
        public string receiveMsg { get; private set; }
        public string errorMessage { get; private set; }
        public string logError { get; private set; }
        private string[] configData { get; set; } = new string[3];

        //Constructor - autogenerated on compile

        /// <summary>
        /// Opens a serial port
        /// </summary>
        /// <param name="errorMessage">an errorMessage</param>
        public void OpenSerialPort()
        {
            errorMessage = String.Empty;
            //TODO create a config file to hold data like baud rate, com port, interval time, reading in a file is more robust and persistent
            //TODO read in serial port data (com port and baud rate)
            readFromConfigFile();

            try
            {
                sp = new SerialPort("COM3", 9600, Parity.None, 8, StopBits.One);
                sp.Open();
            }
            catch (Exception ex)
            {
                //Send error messgage to the form load method in FormMain.cs
                LogError(errorMessage = ex.Message.ToString());

                // close serial port
                sp.Close();
            }
        }

        /// <summary>
        /// CRC16 checksum
        /// </summary>
        /// <param name="data">byte[]</param>
        /// <returns>checkSum byte[] to add to modbus package</returns>
        /// This checksum algorithm was taken from an online tutorial
        private static byte[] CRC16(byte[] data)
        {
            byte[] checkSum = new byte[2];
            ushort reg_crc = 0Xffff;

            for (int i = 0; i < data.Length - 2; i++)
            {
                reg_crc ^= data[i];
                for (int j = 0; j < 8; j++)
                {
                    if ((reg_crc & 0x01) == 1)
                    {
                        reg_crc = (ushort)((reg_crc >> 1) ^ 0xA001);
                    }
                    else
                    {
                        reg_crc = (ushort)(reg_crc >> 1);
                    }
                }
            }
            checkSum[1] = (byte)((reg_crc >> 8) & 0xFF);
            checkSum[0] = (byte)(reg_crc & 0xFF);

            return checkSum;
        }// end Function checkSum

        /// <summary>
        /// Build the byte[] for modbus communication
        /// </summary>
        /// <returns>modbus package</returns>
        public void BuildMessage()
        {
            byte slaveID = 04;// Slave ID - this can be found on the controller menu under Network
            byte functionCode = 03;// Function code - 03 is for reading coils/registers
            ushort startAddress = 0000;// Starting Address - register 40001 holds the turbidity reading as a float
            ushort numberOfRegisters = 0002;// Quantity of Registers to read - only need reg 40001


            // Build Message(FC03)

            message[0] = slaveID;// Slave ID
            message[1] = functionCode;// Function
            message[2] = (byte)(startAddress >> 8);// Starting Address High
            message[3] = (byte)startAddress;// Starting Address Low
            message[4] = (byte)(numberOfRegisters >> 8);// quantity of Registers High
            message[5] = (byte)numberOfRegisters;// quantity of Registers Low
            //add checkSum to byte[]
            byte[] checkSum = CRC16(message);
            message[6] = checkSum[0];// error check Low
            message[7] = checkSum[1];// error check High
        }// end Function BuildMessage

        /// <summary>
        /// Send package over the serial port
        /// </summary>
        /// <param name="frame"></param>
        public void WriteToSP(byte[] frame)
        {
            int count = 0;
            int attempts = 0;
            errorMessage = String.Empty;

            while (count < 4 && attempts < 1)
            {
                try
                {
                    sp.Write(frame, 0, frame.Length);// send frame
                }
                catch (Exception ex)
                {
                    //Send error messgage to the form load method in FormMain.cs
                    LogError(errorMessage = ex.ToString());

                    Thread.Sleep(TimeSpan.FromSeconds(.5));

                    //close serial port, after 4 attempts to connect
                    count++;
                    if (count == 4)
                    {
                        sp.Close();
                        //TODO add message that write failed
                    }
                }
                attempts++;
            }
        }// end Function WriteToSP

        /// <summary>
        /// Read package received over serial port
        /// </summary>
        /// <param name="errorMessage"></param>
        public void ReadFromSP()
        {
            errorMessage = String.Empty;
            try
            {
                buffRec = new byte[sp.BytesToRead];
            }
            catch (Exception ex)
            {
                //Log any error message
                LogError(errorMessage = ex.ToString());

                // close serial port
                sp.Close();
            }

        }// end Function ReadFromSP

        /// <summary>
        /// Prints data out to WinForm and .CSV file
        /// </summary>
        /// <param name="frame"></param>
        /// <param name="buffRec"></param>
        public void PrintModbusMessage(byte[] frame, byte[] buffRec)
        {
            //sendMsg = string.Empty;
            receiveMsg = string.Empty;

            //Send string
            //This is useful for trouble shooting issues with request to the Turbidity Meter
            foreach (var item in frame)
            {
                sendMsg += string.Format("{0:X2} ", item);
            }

            //Receive string
            foreach (var item in buffRec)
            {
                receiveMsg += string.Format("{0:X2} ", item);
                //TODO - Get only bytes that have turbidity reading
                //TODO - To convert to float flip for endianess then convert
                //TODO - write out number along with date and time to file
            }
        
        }// end Function PrintModbusMessage

        /// <summary>
        /// Log error message out to file
        /// </summary>
        /// <param name="errorMessage"></param>
        private void LogError(string errorMessage)
        {
            string dateTimeStamp = DateTime.Now.ToString();
            string path = "log.txt";
            logError = String.Empty;
            try
            {
                // Append new text to an existing file.
                // The using statement automatically flushes AND CLOSES the stream and calls 
                // IDisposable.Dispose on the stream object.
                using (StreamWriter file =
                    new StreamWriter(path, true))
                {
                    file.WriteLine(dateTimeStamp + Environment.NewLine + errorMessage + Environment.NewLine + Environment.NewLine);
                }
            }
            catch (Exception ex)
            {
                //TODO write any errors out to console as they can't be logged
                //The following conditions may cause an exception:
                //The file exists and is read - only
                //The disk may be full
                logError = ex.Message;
            }
        }// end Function LogError

        /// <summary>
        /// Read data in from config file and save in configData[]
        /// </summary>
        private void readFromConfigFile()
        {
            string path = "log.txt";
            errorMessage = String.Empty;
            try
            {
                // Create an instance of StreamReader to read from a file.
                // The using statement also closes the StreamReader.
                using (StreamReader sr = new StreamReader(path))
                {
                    string line;

                    // Read and store in array from the file until 
                    // the end of the file is reached. 
                    while ((line = sr.ReadLine()) != null)
                    {
                        //TODO call method to get only line of data needed and put in configData array
                    }
                }
            }
            catch (Exception ex)
            {
                //Log any error message
                LogError(errorMessage = ex.Message.ToString());
            }
        }// end Function readFromConfigFile
    }
}



//TODO create new data file for each year - in file name include date/year and check that value with current year, if different create new file